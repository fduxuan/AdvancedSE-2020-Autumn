# 消息队列



## 1. 整体思路

* 以`user id`为队列名，给每个用户分配一个消息队列。
* 系统给特定用户发送消息时，将消息**存入该用户对应的消息队列**，同时**存入数据库用于消息持久化**。
* 用户登录时，新建`websocket`连接，并**新建一个消费者**，在消费者接收到消息的回调函数中通过`websocket`向前端推送消息。
* 用户退出登录时，关闭`websocket`连接，并**删除消费者**。由此可以 ==实现用户在线时消息的实时推送，用户离线时的消息阻塞== 。

---



## 2. 遇到的问题

!!! Question
    python版本的rabbitmq client为pika库，消费者开启监听后阻塞执行
    

* **解决：**<u>给每个消费者开启一个新的线程</u>



!!! Question
   	pika是线程不安全的, 尤其是pika所操作的连接与信道不支持多个消费者(线程)共享.

* **解决：**<u>只能为每个消费者(线程)单独分配一个连接和一个信道.</u>

!!! Question
   	无法显式操作每个消费者线程，无法直接删除消费者

* **解决：**<u>试图删除消费者时，由生产者向消息队列**放入特定quit信号**，在消费者接收到消息的回调函数中判断，收到quit信号则停止监听，清理连接和信道.</u>



!!! Question
   	运行一段时间后，pika会丢失与RabbitMQ的连接

* **解决：**<u>关闭rabbitmq的心跳超时检测机制。发送消息时如连接断开，加入**重发机制**。</u>

---



!!! warning
   	尚未解决的问题。目前如果同时开启多个网页登录，就会形成多个web socket连接，对应多个消费者，由于消息只能被消费一次，就只有一个网页能收到web socket消息。

* **难点：**理想状态是 ==一个队列只有一个消费者== ，接收到消息时推送到所有与它绑定的`web-socket-client`。但由于目前是在新建消费者线程时传入对应的`web-socket-client`，绑定到接收消息的回调函数中，而一旦线程开启，**无法更新该回调函数**，导致以上理想状态不可能实现。
* **预想方案：**以`user_id`为交换机名，每次登录时新建绑定到交换机的**匿名队列**、**消费者**和**websocket client**。<u>向交换机发送消息</u>，那么每个队列即可分别消费，不会互相影响。